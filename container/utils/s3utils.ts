import {
    PutObjectCommand,
    DeleteObjectCommand,
    GetObjectCommand,
    S3Client
} from "@aws-sdk/client-s3";
import { createReadStream, createWriteStream } from "fs";
import { access, constants, readdir, stat, unlink } from "fs/promises"; // For checking file existence and deleting local files
import path from "path";
import { Upload } from "@aws-sdk/lib-storage";

function s3ClientSetup() {
    const { AWS_REGION, AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY } = process.env;
    if (!AWS_REGION || !AWS_ACCESS_KEY_ID || !AWS_SECRET_ACCESS_KEY) {
        throw new Error("Please provide the AWS credentials (AWS_REGION, AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY) in environment variables.");
    }
    const s3Client = new S3Client({
        region: AWS_REGION,
        credentials: {
            accessKeyId: AWS_ACCESS_KEY_ID,
            secretAccessKey: AWS_SECRET_ACCESS_KEY
        }
    });
    return s3Client;
}

/**
 * Uploads an object to S3. This function is mostly used to upload files
 * which are generated by FFmpeg (e.g., HLS segments, master playlist).
 *
 * @param {string} bucketName The name of the S3 bucket.
 * @param {string} key The key (path) for the object in S3.
 * @param {string} filePath The local path of the file to upload.
 * @returns {Promise<string>} A promise that resolves with the ETag of the uploaded object, or rejects on error.
 */
export async function UploadObjectOnS3(bucketName: string, key: string, filePath: string): Promise<string> {
    if (!bucketName || !key || !filePath) {
        throw new Error("Please provide BucketName, Key, and filePath properly. Error on UploadObjectOnS3.");
    }

    try {
        // Check if the file exists locally before trying to upload
        await access(filePath, constants.R_OK);
    } catch (error) {
        throw new Error(`Local file not found or unreadable: ${filePath}. Original error: ${(error as Error).message}`);
    }

    const s3Client = s3ClientSetup();
    const fileStream = createReadStream(filePath);

    const command = new PutObjectCommand({
        Bucket: bucketName,
        Key: key,
        Body: fileStream, // Set the Body to the readable stream of the file
        // Optional: You might want to set ContentType based on the file extension
        // ContentType: 'video/mp2t' for .ts segments, 'application/x-mpegURL' for .m3u8 playlists
    });

    try {
        console.log(`Uploading ${filePath} to s3://${bucketName}/${key}`);
        const response = await s3Client.send(command);
        console.log(`Successfully uploaded ${key}. ETag: ${response.ETag}`);
        return response.ETag!; // ETag uniquely identifies the version of the object
    } catch (error) {
        console.error(`Failed to upload ${key} to S3:`, error);
        throw error; // Re-throw the error for the caller to handle
    }
}

/**
 * Deletes an object from S3. This is useful for cleaning up original files
 * from a temporary bucket after processing, or cleaning up generated HLS files.
 *
 * @param {string} bucketName The name of the S3 bucket.
 * @param {string} key The key (path) of the object to delete in S3.
 * @returns {Promise<void>} A promise that resolves when the object is deleted, or rejects on error.
 */
export async function DeleteObjectFromS3(bucketName: string, key: string): Promise<void> {
    if (!bucketName || !key) {
        throw new Error("Please provide BucketName and Key properly. Error on DeleteObjectFromS3.");
    }

    const s3Client = s3ClientSetup();
    const command = new DeleteObjectCommand({
        Bucket: bucketName,
        Key: key,
    });

    try {
        console.log(`Deleting s3://${bucketName}/${key}`);
        await s3Client.send(command);
        console.log(`Successfully deleted ${key} from S3.`);
    } catch (error) {
        console.error(`Failed to delete ${key} from S3:`, error);
        throw error;
    }
}

/**
 * Downloads an object from S3 to a local file path.
 * This is useful for downloading the original file from a temporary S3 bucket
 * before processing it with FFmpeg.
 *
 * @param {string} bucketName The name of the S3 bucket.
 * @param {string} key The key (path) of the object to download from S3.
 * @param {string} filePath The local path where the file should be saved.
 * @returns {Promise<void>} A promise that resolves when the file is downloaded, or rejects on error.
 */
export async function DownloadObjectFromS3(bucketName: string, key: string, filePath: string): Promise<void> {
    if (!bucketName || !key || !filePath) {
        throw new Error("Please provide BucketName, Key, and filePath properly. Error on DownloadObjectFromS3.");
    }

    const s3Client = s3ClientSetup();
    const command = new GetObjectCommand({
        Bucket: bucketName,
        Key: key,
    });

    try {
        console.log(`Downloading s3://${bucketName}/${key} to ${filePath}`);
        const response = await s3Client.send(command);

        if (!response.Body) {
            throw new Error(`No body found for object s3://${bucketName}/${key}`);
        }

        const writeStream = createWriteStream(filePath);

        await new Promise<void>((resolve, reject) => { // Explicitly tell Promise it resolves to void
            (response.Body as any).pipe(writeStream)
                .on('finish', () => {
                    resolve(); // Still here, but type context is clearer
                })
                .on('error', (pipeError: Error) => {
                    reject(pipeError);
                });
        });
    } catch (error) {
        console.error(`Failed to download ${key} from S3:`, error);
        // Clean up the partially downloaded file in case of error
        try {
            await unlink(filePath);
            console.log(`Cleaned up partially downloaded file: ${filePath}`);
        } catch (unlinkError: any) {
            if (unlinkError.code !== 'ENOENT') { // Ignore if file didn't exist
                console.warn(`Could not delete partially downloaded file ${filePath}:`, unlinkError);
            }
        }
        throw error;
    }
}

export async function uploadFileToS3(bucketName: string, key: string, filePath: string): Promise<void> {
    const s3Client = s3ClientSetup();
    const upload = new Upload({
        client: s3Client,
        params: {
            Bucket: bucketName,
            Key: key,
            Body: createReadStream(filePath),
        },
    });

    upload.on("httpUploadProgress", (progress) => {
        console.log(`Uploading ${key}: ${progress.loaded} / ${progress.total}`);
    });

    await upload.done();
    console.log(`✅ Uploaded: ${key}`);
}

export async function uploadFolderToS3(localFolderPath: string, bucketName: string, s3Folder: string): Promise<void> {
    async function walk(currentPath: string, currentS3Path: string) {
        const items = await readdir(currentPath);

        for (const item of items) {
            const localItemPath = path.join(currentPath, item);
            const s3ItemPath = path.join(currentS3Path, item).replace(/\\/g, "/"); // Windows compatibility
            const fileStat = await stat(localItemPath);

            if (fileStat.isDirectory()) {
                await walk(localItemPath, s3ItemPath); // Recurse into subfolder
            } else if (fileStat.isFile()) {
                await uploadFileToS3(bucketName, s3ItemPath, localItemPath);
            }
        }
    }

    await walk(localFolderPath, s3Folder);
    console.log("✅ All files uploaded recursively.");
}